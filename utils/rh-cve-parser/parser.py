import json
import os
import time
from os.path import exists

import requests
import urllib3
from urllib3.exceptions import InsecureRequestWarning
import re

class CVECollector:
    def __init__(self, regenerate=False):
        self.api_url = "https://access.redhat.com/hydra/rest/securitydata/cve.json?after={}per_page={}&page={}&product={}&package=openshift4"
        self.page = 1
        self.per_page = 1000
        self.cvs = []
        self.usable_cvs = []
        self.cut_off_date = "2020-01-01"
        self.regenerate = regenerate
        urllib3.disable_warnings(InsecureRequestWarning)

    def collect(self):
        output_file = os.path.abspath(os.path.dirname(__file__)) + "/" + "current_CVEs.json"
        if not exists(output_file) or self.regenerate:
            while True:
                call_url = self.api_url.format(self.cut_off_date, self.per_page, self.page, "openshift")
                print("url to call: {}".format(call_url))
                r = requests.get(call_url, verify=False)
                collection_responses = r.json()
                print("Processing page:{}, found {} entries".format(self.page, len(collection_responses)))
                if len(collection_responses) == 0 or self.page > 200:
                    break
                else:
                    for response in collection_responses:                        
                        if "cvss3_score" not in response.keys():
                            response["cvss3_score"] = "0.0"
                    self.cvs = self.cvs + collection_responses
                    self.page += 1

            print("Number of CVEs in total: {}".format(len(self.cvs)))

            
            with open(output_file, "w") as json_writer:
                self.cvs = sorted(self.cvs, key=lambda k: k['cvss3_score'], reverse=True)
                json.dump(self.cvs, json_writer, indent=2)
            return self.cvs
        else:
            print("Using the existing downloaded file from {}".format(
                time.strftime("%Y-%m-%d %H:%M:%S", time.localtime(os.stat(output_file).st_mtime))))

class OpenShiftCVEExtractor:
    def __init__(self, cve_collection) -> None:
        self.cve_collection = cve_collection
        self.trigger_words_products = ["openshift4", "4\.9"]

    def extract(self):
        table = "|CVE|CVE level| description| products|\n"
        table += "| --- | --- | --- | --- |\n"
        relevant_cves = self.processor()
        for relevant_cve in relevant_cves:
            table += "|{}|{}|{}|{}|\n".format(relevant_cve["CVE"],relevant_cve["severity"],relevant_cve["bugzilla_description"], "<br/>".join(relevant_cve["affected_packages"]) )
        return table
    
    def processor(self):
        relevant_objects = []
        for cve in self.cve_collection:
            # Go through the list of cves and filter the ones that are relevant for us
            affected_packages = cve["affected_packages"]
            is_added = False
            for packages in affected_packages:
                res = self.match_strings(packages, self.trigger_words_products)
                # Remove double mentions 
                deduped_res = []
                [deduped_res.append(item) for item in res if item not in deduped_res]
                if len(deduped_res) == len(self.trigger_words_products) and not is_added:
                    # print(deduped_res)
                    relevant_objects.append(cve)
                    is_added = True
        return relevant_objects
    
    def match_strings(self, string, string_array):
        matches = []
        for s in string_array:
            match = re.findall(s, string)
            matches.extend(match)
        return matches

if __name__ == "__main__":
    collector = CVECollector(True)
    CVEs_collected = collector.collect()
    extractor = OpenShiftCVEExtractor(CVEs_collected)
    markdown_table = extractor.extract()
    output_file = os.path.abspath(os.path.dirname(__file__)) + "/" + "relevant_CVEs.md"
    with open(output_file, "w") as writer :
        writer.write(markdown_table)    