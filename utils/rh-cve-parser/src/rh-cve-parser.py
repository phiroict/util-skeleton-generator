import json
import os
import time
from os.path import exists

import requests
import urllib3
from urllib3.exceptions import InsecureRequestWarning
import re

"""
    This will go out to the Redhat Security API and get all the CVEs for openshift 4.9 in order of severity

    Returns:
        List of CVEs 
"""


class CVECollector:
    def __init__(self, regenerate=False):
        self.api_url = "https://access.redhat.com/hydra/rest/securitydata/cve.json?after={}per_page={}&page={" \
                       "}&product={}&package=openshift4"
        self.page = 1
        self.per_page = 1000
        self.cvs = []
        self.usable_cvs = []
        self.cut_off_date = "2020-01-01"
        self.regenerate = regenerate
        urllib3.disable_warnings(InsecureRequestWarning)

        """ Does the call to the API and genrating a list of CVEs 
        """

    def collect(self):
        output_file = os.path.abspath(os.path.dirname(__file__)) + "/result/" + "current_CVEs.json"
        if not exists(output_file) or self.regenerate:
            while True:
                call_url = self.api_url.format(self.cut_off_date, self.per_page, self.page, "openshift")
                print("url to call: {}".format(call_url))
                r = requests.get(call_url, verify=False)
                collection_responses = r.json()
                print("Processing page:{}, found {} entries".format(self.page, len(collection_responses)))
                # If there are no more pages or we are over 200 pages we stop.
                if len(collection_responses) == 0 or self.page > 200:
                    break
                else:
                    # There are CVEs issues that have no severity and have therefor no CVSS3 score, for sorting
                    # purposes we assigning a 0.0 to that field to avoid breaking the code.
                    for response in collection_responses:
                        if "cvss3_score" not in response.keys():
                            response["cvss3_score"] = "0.0"
                    self.cvs = self.cvs + collection_responses
                    self.page += 1

            print("Number of CVEs in total: {}".format(len(self.cvs)))

            with open(output_file, "w") as json_writer:
                self.cvs = sorted(self.cvs, key=lambda k: k['cvss3_score'], reverse=True)
                json.dump(self.cvs, json_writer, indent=2)
            return self.cvs
        else:
            # FIXME: Does not work at this moment so we pass the regenerate in the main method so we do not get here.
            print("Using the existing downloaded file from {}".format(
                time.strftime("%Y-%m-%d %H:%M:%S", time.localtime(os.stat(output_file).st_mtime))))


"""
    Does take the collection of CVEs and then filters out the openshift 4.9 issues. 

        Returns:
            A markdown table with all the issues ready to be plugged into the wikipage. 
"""


class OpenShiftCVEExtractor:
    def __init__(self, cve_collection) -> None:
        self.cve_collection = cve_collection
        self.trigger_words_products = ["openshift4", "4.10"]

    def extract(self):
        table = "|CVE|CVE level| description| products|\n"
        table += "| --- | --- | --- | --- |\n"
        relevant_cves = self.processor()
        for relevant_cve in relevant_cves:
            table += "|{}|{}|{}|{}|\n".format(relevant_cve["CVE"], relevant_cve["severity"],
                                              relevant_cve["bugzilla_description"],
                                              "<br/>".join(relevant_cve["affected_packages"]))
        return table

    """
    Will select a CVE when any of the keywords from trigger_words_products are present. 
    Note that it will include unrelated affected packages as well to show the blast radius of the CVE and not a small
    aspect. I guess that can be a discussion point with the team.
    """
    def processor(self):
        relevant_objects = []
        for cve in self.cve_collection:
            # Go through the list of cves and filter the ones that are relevant for us
            affected_packages = cve["affected_packages"]
            is_added = False
            for packages in affected_packages:
                res = self.match_strings(packages, self.trigger_words_products)
                # Remove double mentions
                deduped_res = []
                [deduped_res.append(item) for item in res if item not in deduped_res]
                if len(deduped_res) == len(self.trigger_words_products) and not is_added:
                    # print(deduped_res)
                    relevant_objects.append(cve)
                    is_added = True
        return relevant_objects

    def match_strings(self, string, string_array):
        matches = []
        for s in string_array:
            match = re.findall(re.escape(s), string)
            matches.extend(match)
        if len(matches) > 1:
            print("DEBUG: On string {}, matches: {}".format(string, matches))
            return matches
        else:
            return []


class OutputWriter:
    def __init__(self) -> None:
        self.targetdir = "result"
        os.makedirs(self.targetdir, exist_ok=True)

    def writeout(self, data, data_path="relevant_CVEs.md"):
        print("Writing to {}/{}".format)
        with open("{}/{}".format(self.targetdir, data_path), "w") as writer_inner:
            writer_inner.write(data)


if __name__ == "__main__":
    collector = CVECollector(True)
    CVEs_collected = collector.collect()
    extractor = OpenShiftCVEExtractor(CVEs_collected)
    markdown_table = extractor.extract()
    writer = OutputWriter()
    writer.writeout(markdown_table)
